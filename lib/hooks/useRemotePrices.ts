"use client";
/**
 * Fetches community-contributed prices from /data/prices.json (generated by
 * the update-prices GitHub Action). Falls back to bundled seed prices on
 * fetch failure. Caches the result in module scope to avoid re-fetching.
 */
import { useState, useEffect } from "react";
import type { SwissPrice } from "@/lib/types";

interface PricesPayload {
  generated: string;
  count: number;
  prices: SwissPrice[];
}

const isValidPrice = (item: unknown): item is SwissPrice => {
  if (typeof item !== "object" || item === null) return false;
  const obj = item as Record<string, unknown>;
  return (
    typeof obj.id === "string" &&
    typeof obj.laptopId === "string" &&
    typeof obj.retailer === "string" &&
    typeof obj.price === "number" &&
    obj.price > 0 &&
    typeof obj.dateAdded === "string"
  );
};

/** Module-level cache â€” survives re-renders but not page refresh */
let cachedPrices: SwissPrice[] | null = null;
let fetchPromise: Promise<SwissPrice[] | null> | null = null;

/** Resolve the basePath at runtime so the fetch works on both localhost and GitHub Pages */
const getBasePath = (): string => {
  if (typeof window === "undefined") return "";
  // Next.js injects __NEXT_DATA__.basePath at runtime
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const bp = (window as any).__NEXT_DATA__?.basePath;
  return typeof bp === "string" ? bp : "";
};

const fetchRemotePrices = async (): Promise<SwissPrice[] | null> => {
  try {
    const basePath = getBasePath();
    const res = await fetch(`${basePath}/data/prices.json`, {
      cache: "no-cache",
    });
    if (!res.ok) return null;

    const data: unknown = await res.json();
    if (typeof data !== "object" || data === null) return null;

    const payload = data as PricesPayload;
    if (!Array.isArray(payload.prices)) return null;

    const valid = payload.prices.filter(isValidPrice);
    return valid.length > 0 ? valid : null;
  } catch {
    return null;
  }
};

export interface RemotePricesState {
  /** Remote prices if fetched, null if still loading or failed */
  remotePrices: SwissPrice[] | null;
  /** True while the initial fetch is in-flight */
  loading: boolean;
  /** ISO timestamp from the generated payload, if available */
  generatedAt: string | null;
}

export const useRemotePrices = (): RemotePricesState => {
  const [remotePrices, setRemotePrices] = useState<SwissPrice[] | null>(cachedPrices);
  const [loading, setLoading] = useState(cachedPrices === null);
  const [generatedAt, setGeneratedAt] = useState<string | null>(null);

  useEffect(() => {
    if (cachedPrices !== null) {
      setRemotePrices(cachedPrices);
      setLoading(false);
      return;
    }

    // Deduplicate concurrent fetches
    if (!fetchPromise) {
      fetchPromise = fetchRemotePrices();
    }

    let cancelled = false;
    fetchPromise.then((prices) => {
      if (cancelled) return;
      if (prices) {
        cachedPrices = prices;
        setRemotePrices(prices);
      }
      setLoading(false);
      fetchPromise = null;
    });

    return () => {
      cancelled = true;
    };
  }, []);

  // Also parse generatedAt from the cached data
  useEffect(() => {
    if (remotePrices && !generatedAt) {
      const basePath = getBasePath();
      fetch(`${basePath}/data/prices.json`, { cache: "no-cache" })
        .then((r) => r.json())
        .then((data: PricesPayload) => {
          if (data?.generated) setGeneratedAt(data.generated);
        })
        .catch(() => {});
    }
  }, [remotePrices, generatedAt]);

  return { remotePrices, loading, generatedAt };
};
