"use client";
/**
 * Fetches community-contributed prices from /data/prices.json (generated by
 * the update-prices GitHub Action). Falls back to bundled seed prices on
 * fetch failure. Caches the result in module scope to avoid re-fetching.
 */
import { useState, useEffect } from "react";
import type { SwissPrice } from "@/lib/types";

interface PricesPayload {
  generated: string;
  count: number;
  prices: SwissPrice[];
}

interface CachedResult {
  prices: SwissPrice[];
  generatedAt: string | null;
}

const isValidPrice = (item: unknown): item is SwissPrice => {
  if (typeof item !== "object" || item === null) return false;
  const obj = item as Record<string, unknown>;
  return (
    typeof obj.id === "string" &&
    typeof obj.laptopId === "string" &&
    typeof obj.retailer === "string" &&
    typeof obj.price === "number" &&
    obj.price > 0 &&
    typeof obj.dateAdded === "string"
  );
};

/** Module-level cache â€” survives re-renders but not page refresh */
let cached: CachedResult | null = null;
let fetchPromise: Promise<CachedResult | null> | null = null;

/** Resolve the basePath at runtime so the fetch works on both localhost and GitHub Pages */
const getBasePath = (): string => {
  if (typeof window === "undefined") return "";
  // Next.js injects __NEXT_DATA__.basePath at runtime
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const bp = (window as any).__NEXT_DATA__?.basePath;
  return typeof bp === "string" ? bp : "";
};

const fetchRemotePrices = async (): Promise<CachedResult | null> => {
  try {
    const basePath = getBasePath();
    const res = await fetch(`${basePath}/data/prices.json`, {
      cache: "no-cache",
    });
    if (!res.ok) return null;

    const data: unknown = await res.json();
    if (typeof data !== "object" || data === null) return null;

    const payload = data as PricesPayload;
    if (!Array.isArray(payload.prices)) return null;

    const valid = payload.prices.filter(isValidPrice);
    if (valid.length === 0) return null;

    return {
      prices: valid,
      generatedAt: typeof payload.generated === "string" ? payload.generated : null,
    };
  } catch {
    return null;
  }
};

export interface RemotePricesState {
  /** Remote prices if fetched, null if still loading or failed */
  remotePrices: SwissPrice[] | null;
  /** True while the initial fetch is in-flight */
  loading: boolean;
  /** ISO timestamp from the generated payload, if available */
  generatedAt: string | null;
}

export const useRemotePrices = (): RemotePricesState => {
  const [remotePrices, setRemotePrices] = useState<SwissPrice[] | null>(cached?.prices ?? null);
  const [loading, setLoading] = useState(cached === null);
  const [generatedAt, setGeneratedAt] = useState<string | null>(cached?.generatedAt ?? null);

  useEffect(() => {
    if (cached !== null) {
      setRemotePrices(cached.prices);
      setGeneratedAt(cached.generatedAt);
      setLoading(false);
      return;
    }

    // Deduplicate concurrent fetches
    if (!fetchPromise) {
      fetchPromise = fetchRemotePrices();
    }

    let cancelled = false;
    fetchPromise.then((result) => {
      if (cancelled) return;
      if (result) {
        cached = result;
        setRemotePrices(result.prices);
        setGeneratedAt(result.generatedAt);
      }
      setLoading(false);
      fetchPromise = null;
    });

    return () => {
      cancelled = true;
    };
  }, []);

  return { remotePrices, loading, generatedAt };
};
